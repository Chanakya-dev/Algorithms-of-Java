## **Generate All Permutations of a String / Array**

### **Problem**

Given a string or array, generate **all possible permutations**.

* **Permutation:** An arrangement of all elements in **every possible order**.
* **Example:** `"abc"` → `["abc", "acb", "bac", "bca", "cab", "cba"]`

---

### **Key Concepts**

1. **Backtracking / Recursion** – Fix one element at a time, then **permute the remaining elements**.
2. **Base Case** – When all elements have been fixed (i.e., the start index reaches the end), we have one permutation.
3. **Recursive Case** – Swap the current element with each element starting from the current index, recurse, then **backtrack** (swap back).

---

### **Step-by-Step Example: `"abc"`**

1. Start with index 0 → swap index 0 with 0 → `"abc"`

   * Recurse index 1 → swap index 1 with 1 → `"abc"` → recurse index 2 → `"abc"` (print)
   * Swap index 1 with 2 → `"acb"` → recurse index 2 → `"acb"` (print)
   * Backtrack → swap back → `"abc"`

2. Swap index 0 with 1 → `"bac"` → recurse index 1 → …

3. Swap index 0 with 2 → `"cab"` → recurse index 1 → …

All permutations generated.

---

### **Code Example (Java)**

```java
public class Permutations {
    public static void generatePermutations(char[] arr, int start) {
        // Base case: all characters fixed
        if (start == arr.length - 1) {
            System.out.println(String.valueOf(arr));
            return;
        }

        // Recursive case: swap current element with all possible elements
        for (int i = start; i < arr.length; i++) {
            swap(arr, start, i); // swap
            generatePermutations(arr, start + 1); // recurse
            swap(arr, start, i); // backtrack
        }
    }

    private static void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        String str = "abc";
        generatePermutations(str.toCharArray(), 0);
    }
}
```

---

### **Output for `"abc"`**

```
abc
acb
bac
bca
cab
cba
```

---

### **Key Points**

1. **Backtracking**: Swap → recurse → swap back.
2. Base case ensures **termination** when all elements are used.
3. Total permutations = `n!` for `n` characters → factorial time complexity.
4. Works for **arrays or strings**, just convert string to array of chars.
5. Can be adapted to **arrays with duplicates** (requires extra logic to avoid duplicate permutations).

---
