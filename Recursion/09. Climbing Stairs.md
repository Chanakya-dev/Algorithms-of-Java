## **Climbing Stairs / Number of Ways to Reach Top**

### **Problem**

You are climbing a staircase with `n` steps.

* You can climb **1 step** or **2 steps** at a time.
* **Goal:** Count the total number of distinct ways to reach the top.

**Example:**

* Input: `n = 4`
* Output: `5` ways
* Explanation:

  1. 1 + 1 + 1 + 1
  2. 1 + 1 + 2
  3. 1 + 2 + 1
  4. 2 + 1 + 1
  5. 2 + 2

---

### **Observation / Recursive Formula**

If `f(n)` = number of ways to reach step `n`:

[
f(n) = f(n-1) + f(n-2)
]

* **f(n-1)** → last move was a single step
* **f(n-2)** → last move was two steps

**Base Cases:**

[
f(0) = 1 \quad (\text{no steps, 1 way to stay at start})
f(1) = 1 \quad (\text{only 1 way to reach first step})
]

> Notice: This is the **Fibonacci pattern**!

---

### **1. Recursive Approach**

```java
public class ClimbingStairs {
    public static int climbStairs(int n) {
        if (n == 0 || n == 1) return 1; // base case
        return climbStairs(n - 1) + climbStairs(n - 2); // recursive case
    }

    public static void main(String[] args) {
        int n = 4;
        System.out.println("Ways to climb " + n + " stairs: " + climbStairs(n)); // Output: 5
    }
}
```

* **Time Complexity:** O(2^n) → exponential, not efficient for large `n`.

---

### **2. Recursive + Memoization (Top-Down DP)**

```java
import java.util.Arrays;

public class ClimbingStairs {
    public static int climbStairs(int n, int[] memo) {
        if (n == 0 || n == 1) return 1;

        if (memo[n] != -1) return memo[n]; // use stored result

        memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);
        return memo[n];
    }

    public static void main(String[] args) {
        int n = 10;
        int[] memo = new int[n + 1];
        Arrays.fill(memo, -1);
        System.out.println("Ways to climb " + n + " stairs: " + climbStairs(n, memo));
    }
}
```

* **Time Complexity:** O(n)
* **Space Complexity:** O(n) → recursion stack + memo array

---

### **3. Iterative / Bottom-Up DP Approach**

```java
public class ClimbingStairs {
    public static int climbStairs(int n) {
        if (n == 0 || n == 1) return 1;

        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        return dp[n];
    }

    public static void main(String[] args) {
        int n = 10;
        System.out.println("Ways to climb " + n + " stairs: " + climbStairs(n)); // Output: 89
    }
}
```

* **Time Complexity:** O(n)
* **Space Complexity:** O(n)

---

### **4. Optimized Space Iterative Approach**

```java
public class ClimbingStairs {
    public static int climbStairs(int n) {
        if (n == 0 || n == 1) return 1;

        int prev2 = 1, prev1 = 1, curr = 0;
        for (int i = 2; i <= n; i++) {
            curr = prev1 + prev2;
            prev2 = prev1;
            prev1 = curr;
        }
        return curr;
    }

    public static void main(String[] args) {
        int n = 10;
        System.out.println("Ways to climb " + n + " stairs: " + climbStairs(n)); // Output: 89
    }
}
```

* **Time Complexity:** O(n)
* **Space Complexity:** O(1) → very efficient

---

### **Key Points**

1. **Recursive formula:** `f(n) = f(n-1) + f(n-2)` → similar to Fibonacci
2. **Base cases:** `f(0)=1`, `f(1)=1`
3. **Techniques:**

   * Simple recursion → exponential
   * Recursion + memoization → top-down DP → linear
   * Iterative DP → bottom-up → linear + efficient
   * Space optimized → only two variables needed
4. Variations often asked in interviews:

   * Climb stairs with **1, 2, 3 steps** at a time
   * Count ways **avoiding broken steps**
   * Return **all possible sequences** of steps
