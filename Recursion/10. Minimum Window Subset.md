## **1. Minimum Window Subset (Simplified Version)**

**Problem:**

* Given a string `S` and a set of characters `T`, find the **smallest substring of S that contains all characters of T**.
* Example:

  * `S = "ADOBECODEBANC"`, `T = "ABC"` → Minimum window = `"BANC"`

**Recursive Idea:**

* Not usually solved purely recursively due to efficiency concerns, but conceptually:

  1. Try all possible substrings of `S`.
  2. Check if substring contains all characters of `T`.
  3. Keep track of **minimum length substring** that satisfies the condition.

**Time Complexity:** Exponential if brute force (O(n^3)) → generally optimized with sliding window + hashmap.

**Brute Force Recursive Concept:**

```text
Function minWindow(S, T):
    If S is empty:
        return infinity
    For each substring starting from index 0:
        Check if it contains all chars of T
        Update minimum length
    Recurse for S[1:]  (skip first character)
```

> This is more **conceptual**; sliding window is preferred in practice.

---

## **2. Subset Sum Problem (Classic)**

**Problem:**

* Given an array `arr[]` and target sum `S`, determine if **any subset of arr[] sums to S**.

**Recursive Idea:**

* For each element, **choose** to include or exclude it.

**Recursive Formula:**

```
subsetSum(arr, n, S) = subsetSum(arr, n-1, S)    // exclude current element
                       OR
                       subsetSum(arr, n-1, S-arr[n-1])  // include current element
```

**Base Cases:**

* If `S == 0` → return true (subset found)
* If `n == 0` → return false (no elements left)

**Java Code (Recursive)**

```java
public class SubsetSum {
    public static boolean subsetSum(int[] arr, int n, int sum) {
        if (sum == 0) return true;
        if (n == 0) return false;

        // If current element > sum, skip it
        if (arr[n-1] > sum) return subsetSum(arr, n-1, sum);

        // Include OR exclude
        return subsetSum(arr, n-1, sum) || subsetSum(arr, n-1, sum - arr[n-1]);
    }

    public static void main(String[] args) {
        int[] arr = {3, 34, 4, 12, 5, 2};
        int sum = 9;
        System.out.println(subsetSum(arr, arr.length, sum)); // true
    }
}
```

* **Time Complexity:** O(2^n)
* **Space Complexity:** O(n) (recursion stack)

> Can be optimized using **memoization / DP**.

---

## **3. Coin Change Problem (Basic Recursive Version)**

**Problem:**

* Given coins `[c1, c2, ..., cn]` and amount `S`, find **minimum number of coins** to make amount `S`.
* Infinite supply of each coin.

**Recursive Idea:**

* For each coin, **try including it** and **recurse for remaining amount**.
* Take **minimum of all options**.

**Recursive Formula:**

```
coinChange(coins, n, S) = 
    if S == 0 → 0
    else → min(1 + coinChange(coins, n, S - coins[i])) for all coins[i] <= S
```

**Java Code (Recursive)**

```java
import java.util.Arrays;

public class CoinChange {
    public static int coinChange(int[] coins, int sum) {
        if (sum == 0) return 0;

        int minCoins = Integer.MAX_VALUE;

        for (int coin : coins) {
            if (sum - coin >= 0) {
                int res = coinChange(coins, sum - coin);
                if (res != Integer.MAX_VALUE) {
                    minCoins = Math.min(minCoins, res + 1);
                }
            }
        }
        return minCoins;
    }

    public static void main(String[] args) {
        int[] coins = {1, 2, 5};
        int sum = 11;
        int result = coinChange(coins, sum);
        System.out.println(result == Integer.MAX_VALUE ? -1 : result); // Output: 3
    }
}
```

* **Time Complexity:** O(S^n) → very high for large S
* Optimized using **DP / memoization** → O(n*S)

---

### **Key Points Across These Problems**

1. **Branching / Choice Concept:**

   * Subset Sum → include or exclude
   * Coin Change → try all coins
   * Minimum Window → try all substrings (conceptually)

2. **Base Cases are Crucial:**

   * Prevent infinite recursion
   * Define success / failure clearly

3. **Optimization:**

   * Memoization / DP is key to make these feasible for large input.
