## **Rat in a Maze / All Paths in a Grid**

### **Problem**

Given a `N x N` maze (or grid) with **0s and 1s**:

* `1` → open path
* `0` → blocked path

A rat starts at `(0,0)` and wants to reach `(N-1, N-1)`.
We want to **find all possible paths** from start to finish.

* The rat can move **right** or **down** (sometimes four directions: up, down, left, right).

**Example Maze (4x4):**

```
1 0 0 0
1 1 0 1
0 1 0 0
1 1 1 1
```

* One path: `Down → Down → Right → Right → Down → Right`

---

### **Key Concepts**

1. **Backtracking** – Explore all possible moves, and **undo the move** (backtrack) when stuck.

2. **Recursive Approach** – At each cell:

   * Check if move is **safe** (inside bounds and open path)
   * Move in possible directions (right, down)
   * Recurse to the next cell
   * Mark current cell as **visited** to avoid cycles

3. **Base Case** – If the rat reaches the destination `(N-1, N-1)`, store or print the path.

---

### **Step-by-Step Approach**

1. Start at `(0,0)`
2. Check if current cell is **valid** (inside grid and not blocked)
3. Add the cell to the **current path**
4. Try moving in all allowed directions:

   * Right → `(i, j+1)`
   * Down → `(i+1, j)`
5. Recurse for each valid move
6. Backtrack → remove the cell from the current path

---

### **Code Example (Java)**

```java
import java.util.*;

public class RatInMaze {
    public static void findPaths(int[][] maze) {
        int n = maze.length;
        boolean[][] visited = new boolean[n][n];
        List<String> path = new ArrayList<>();
        findPathsHelper(maze, 0, 0, visited, path, "");
    }

    private static void findPathsHelper(int[][] maze, int i, int j, boolean[][] visited, List<String> path, String move) {
        int n = maze.length;
        
        // Base Case: reached destination
        if (i == n - 1 && j == n - 1) {
            System.out.println(move); // Print one path
            return;
        }

        // Check boundaries and if cell is open and not visited
        if (i < 0 || j < 0 || i >= n || j >= n || maze[i][j] == 0 || visited[i][j]) {
            return;
        }

        visited[i][j] = true;

        // Move Down
        findPathsHelper(maze, i + 1, j, visited, path, move + "D");
        // Move Right
        findPathsHelper(maze, i, j + 1, visited, path, move + "R");
        // If 4 directions allowed, also try Up and Left

        visited[i][j] = false; // Backtrack
    }

    public static void main(String[] args) {
        int[][] maze = {
            {1, 0, 0, 0},
            {1, 1, 0, 1},
            {0, 1, 0, 0},
            {1, 1, 1, 1}
        };
        findPaths(maze);
    }
}
```

---

### **Output (Paths using “D” for down, “R” for right)**

```
DDRDRR
DRDDRR
```

---

### **Key Points**

1. **Backtracking:** explore all possible moves, undo the move when stuck.
2. **Safety Check:** ensure we don’t go out of bounds or revisit blocked cells.
3. **Base Case:** destination reached → print/store path.
4. Time Complexity: O(2^(N^2)) in worst case (all cells open → exponential)
5. Space Complexity: O(N^2) for `visited` + recursion stack

---

✅ **Variation Questions in Interviews:**

* Print **all paths** in a grid of size `M x N`
* Count **total number of paths**
* Allow **4-direction movement** (up, down, left, right)
* Find paths with **minimum steps**
* Maze with obstacles or weights
